displayed_sidebar: docs
import QSOverview from '../_assets/commonMarkdown/quickstart-overview-tip.mdx'

# 架构

StarRocks 拥有强大的架构。整个系统仅包含两种类型的组件：“前端节点”和“后端节点”。前端节点称为 **FE**。后端节点分为两种类型：**BE** 和 **CN**（计算节点）。当数据使用 本地存储 时，部署 BE；当数据存储在 对象存储 或 HDFS 时，部署 CN。StarRocks 不依赖任何外部组件，这简化了部署和维护。节点可以横向扩展而无需停机。此外，StarRocks 为 元数据 和 服务数据 提供了 副本 机制，这提高了 数据可靠性 并有效防止了单点故障（SPOF）。

StarRocks 兼容 MySQL 通信协议并支持标准 SQL。用户可以通过 MySQL 客户端连接到 StarRocks，以获得即时且有价值的洞察。

## 架构选择

StarRocks 支持 存算一体模式（其中每个 BE 在其 本地存储 上拥有一部分数据）和 存算分离模式（其中所有数据都存储在 对象存储 或 HDFS 上，并且每个 CN 在其 本地存储 上只有一个缓存）。您可以根据需要决定数据的存储位置。

![架构选择](../_assets/architecture_choices.png)

### 存算一体模式

本地存储 对于 实时查询 提供更好的 查询延迟。

作为一种典型的大规模并行处理 (MPP) 数据库，StarRocks 支持 存算一体架构。在此架构中，BE 负责 数据存储 和 计算。直接访问 BE 节点上的 本地数据 可实现 本地计算，避免了 数据传输 和 数据拷贝，并提供超快的 查询 和 数据分析 性能。这种架构支持 多副本 数据存储，增强了集群处理 高并发查询 的能力，并确保了 数据可靠性。它非常适合需要最佳 查询性能 的场景。

![存算一体架构](../_assets/shared-nothing.png)

#### 节点

在 存算一体架构 中，StarRocks 包含两种类型的节点：FE 和 BE。

- FE 负责 元数据管理 和 构建 执行计划。
- BE 执行 查询计划 并存储数据。BE 利用 本地存储 来加速查询，并使用 多副本 机制来确保 数据高可用。

##### FE

FE 负责 元数据管理、客户端连接管理、查询规划 和 查询调度。每个 FE 使用 BDB JE (Berkeley DB Java Edition) 在其内存中存储和维护一份完整的 元数据 副本，确保所有 FE 之间的服务一致性。FE 可以作为 Leader、Follower 和 Observer 运行。如果 Leader 节点崩溃，Follower 将根据 Raft 协议选举出 Leader。

| **FE 角色** | **元数据管理** | **Leader 选举** |
| ----------- |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| ---------------------------------- |
| Leader      | Leader FE 读取和写入 元数据。Follower 和 Observer FE 只能读取 元数据。它们将 元数据 写入请求路由到 Leader FE。Leader FE 更新 元数据 后，使用 Raft 协议将 元数据 变更同步到 Follower 和 Observer FE。只有当 元数据 变更同步到半数以上的 Follower FE 后，数据写入才被认为是成功的。 | 严格来说，Leader FE 也是一个由 Follower FE 选举出来的 Follower 节点。要执行 Leader 选举，集群中半数以上的 Follower FE 必须处于活动状态。当 Leader FE 发生故障时，Follower FE 将发起新一轮的 Leader 选举。 |
| Follower    | Follower 只能读取 元数据。它们同步并重放 Leader FE 的日志来更新 元数据。 | Follower 参与 Leader 选举，这要求集群中半数以上的 Follower 处于活动状态。 |
| Observer   | 同步并重放 Leader FE 的日志来更新 元数据。 | Observer 主要用于提高集群的 查询并发度。Observer 不参与 Leader 选举，因此不会增加集群的 Leader 选举压力。 |

##### BE

BE 负责 数据存储 和 SQL 执行。

- 数据存储：BE 具有相同的数据存储能力。FE 根据预定义规则将数据分发到 BE。BE 对 摄取 的数据进行转换，以所需格式写入数据，并为数据生成索引。

- SQL 执行：FE 根据查询语义将每个 SQL 查询解析为 逻辑执行计划，然后将 逻辑计划 转换为可在 BE 上执行的 物理执行计划。存储目标数据的 BE 执行查询。这消除了 数据传输 和 复制 的需要，从而实现 高查询性能。

### 存算分离模式

对象存储 和 HDFS 在成本、可靠性和 可扩展性 方面具有优势。除了存储 可扩展性，由于 存算分离，CN 节点可以按需添加和删除，而无需 数据均衡。

在 存算分离架构 中，BE 被“计算节点（CN）”取代，它们仅负责数据计算任务和缓存 热数据。数据存储在低成本、可靠的 远端存储 系统中，例如 Amazon S3、Google Cloud Storage、Azure Blob Storage、MinIO 等。当缓存命中时，查询性能 与 存算一体架构 相当。CN 节点可以在几秒钟内按需添加或删除。这种架构降低了存储成本，确保了更好的 资源隔离，并提供了 高弹性 和 可扩展性。

存算分离架构 与 存算一体架构 类似，都保持了简单的设计。它仅包含两种类型的节点：FE 和 CN。唯一的区别是用户需要预置一个后端 对象存储。

![存算分离架构](../_assets/shared-data.png)

#### 节点

在 存算分离架构 中，FE 节点提供与 存算一体架构 中 FE 相同的功能。

BE 被 CN（计算节点）取代，存储功能被卸载到 对象存储 或 HDFS。CN 是 无状态 计算节点，执行除 数据存储 外的所有 BE 功能。

#### 存储

StarRocks 存算分离集群 支持两种存储方案：对象存储（例如 AWS S3、Google GCS、Azure Blob Storage 或 MinIO）和 HDFS。

在 存算分离集群 中，数据文件格式与 存算一体集群 保持一致（其特点是 存储和计算耦合）。数据被组织成 Segment 文件，各种索引技术在 存算分离表 中被重用， 存算分离表 是专门用于 存算分离集群 的表。

#### 缓存

StarRocks 存算分离集群 将 数据存储 和 计算 解耦，允许它们独立扩展，从而降低成本并增强弹性。然而，这种架构可能会影响 查询性能。

为了减轻这种影响，StarRocks 建立了 多级数据访问系统，涵盖 内存、本地磁盘 和 远端存储，以更好地满足各种业务需求。

热数据 查询 直接扫描缓存，然后扫描 本地磁盘；而 冷数据 需要从 对象存储 加载到 本地缓存 以加速后续查询。通过将 热数据 保持在靠近 计算单元 的位置，StarRocks 实现了真正的高性能计算和经济高效的存储。此外，通过 数据预取策略 优化了 冷数据 访问，有效消除了 查询性能 限制。

在 创建表 时可以启用缓存。如果启用缓存，数据将同时写入 本地磁盘 和 后端 对象存储。在查询期间，CN 节点首先从 本地磁盘 读取数据。如果未找到数据，将从后端 对象存储 中检索数据并同时缓存到 本地磁盘。

<QSOverview />

---
displayed_sidebar: docs
---
import QSOverview from '../_assets/commonMarkdown/quickstart-overview-tip.mdx'

# アーキテクチャ

StarRocks はシンプルなアーキテクチャを備えています。システム全体は、フロントエンドとバックエンドの 2 種類のコンポーネントのみで構成されています。フロントエンドノードは **FE** と呼ばれます。バックエンドノードには、**BE** と **CN** (コンピュートノード) の 2 種類があります。データのローカルストレージを使用する場合は BE をデプロイし、データがオブジェクトストレージまたは HDFS に保存されている場合は CN をデプロイします。StarRocks は外部コンポーネントに依存しないため、デプロイとメンテナンスが簡素化されます。ノードは、サービスを中断することなく水平方向に拡張できます。さらに、StarRocks はメタデータとサービスデータのレプリカメカニズムを備えており、データ信頼性を向上させ、シングルポイント障害 (SPOF) を効果的に防止します。

StarRocks は MySQL プロトコルと互換性があり、標準 SQL をサポートしています。ユーザーは MySQL クライアントから StarRocks に簡単に接続して、即座に価値のある洞察を得ることができます。

## アーキテクチャの選択

StarRocks は、shared nothing (各 BE はローカルストレージにデータの一部を持つ) と shared-data (すべてのデータはオブジェクトストレージまたは HDFS 上にあり、各 CN はローカルストレージにキャッシュのみを持つ) をサポートしています。要件に応じて、データの保存場所を決定できます。

![Architecture choices](../_assets/architecture_choices.png)

### shared nothing

ローカルストレージは、リアルタイムクエリに対してより低いクエリレイテンシを提供します。

典型的な大規模並列処理 (MPP) データベースとして、StarRocks は shared nothing アーキテクチャをサポートしています。このアーキテクチャでは、BE はデータストレージと計算を担当します。BE モードでのローカルデータへの直接アクセスは、ローカル計算を実行し、データ転送とデータコピーを回避し、超高速なクエリおよび分析パフォーマンスを提供できます。このアーキテクチャは、マルチレプリカデータストレージをサポートし、高同時実行クエリを処理するクラスタの能力を強化し、データ信頼性を確保します。これは、最適なクエリパフォーマンスを追求するシナリオに最適です。

![shared-data-arch](../_assets/shared nothing.png)

#### ノード

shared nothing アーキテクチャでは、StarRocks は FE と BE の 2 種類のノードで構成されています。

- FE は、メタデータ管理と実行プランの構築を担当します。
- BE は、クエリプランを実行し、データを保存します。BE はローカルストレージを利用してクエリを高速化し、マルチレプリカメカニズムを利用して高いデータ可用性を確保します。

##### FE

FE は、メタデータ管理、クライアント接続管理、クエリプランニング、およびクエリスケジューリングを担当します。各 FE は、BDB JE (Berkeley DB Java Edition) を使用して、メモリ内にメタデータの完全なコピーを保存および維持し、すべての FE で一貫したサービスを保証します。FE は、leader、follower、および observer として機能できます。leader ノードがクラッシュした場合、follower は Raft プロトコルに従って leader を選出します。

| **FE Role** | **Metadata management**                                                                                                                                                                                                                                                                                                                                                                                                | **Leader election**                |
| ----------- |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| ---------------------------------- |
| Leader      | leader FE はメタデータを読み書きします。Follower FE と observer FE はメタデータのみを読み取ることができます。メタデータ書き込みリクエストを leader FE にルーティングします。leader FE はメタデータを更新し、Raft プロトコルを使用してメタデータの変更を follower FE と observer FE に同期します。メタデータの変更が半数以上の follower FE に同期された場合にのみ、データ書き込みが成功したと見なされます。 | 技術的には、leader FE も follower ノードであり、follower FE から選出されます。leader 選挙を実行するには、クラスタ内の半数以上の follower FE がアクティブである必要があります。leader FE に障害が発生すると、follower FE は別の leader 選挙を開始します。 |
| Follower    | Follower はメタデータのみを読み取ることができます。leader FE からログを同期および再生して、メタデータを更新します。                                                                                                                                                                                                                                                                                                                                             | Follower は leader 選挙に参加します。これには、クラスタ内の半数以上の follower がアクティブであることが必要です。 |
| Observer   | Observer は leader FE からログを同期および再生して、メタデータを更新します。                                                                                                                                                                                                                                                                                                                                                                         | Observer は主にクラスタのクエリ同時実行性を向上させるために使用されます。Observer は leader 選挙に参加しないため、クラスタに leader 選択のプレッシャーを追加することはありません。|

##### BE

BE は、データストレージと SQL 実行を担当します。

- データストレージ: BE は同等のデータストレージ機能を備えています。FE は、事前定義されたルールに従ってデータを BE に分散します。BE は取り込まれたデータを変換し、必要な形式でデータを書き込み、データのインデックスを生成します。

- SQL 実行: FE は、クエリのセマンティクスに従って各 SQL クエリを論理実行プランに解析し、次に論理プランを BE で実行できる物理実行プランに変換します。ターゲットデータを保存する BE がクエリを実行します。これにより、データ転送とコピーが不要になり、高いクエリパフォーマンスが実現します。

### Shared-data

オブジェクトストレージと HDFS は、コスト、信頼性、および拡張性の利点を提供します。ストレージの拡張性に加えて、ストレージとコンピュートが分離されているため、データをリバランスせずに CN ノードを追加および削除できます。

shared-data アーキテクチャでは、BE は「コンピュートノード (CN)」に置き換えられ、CN はデータ計算タスクとホットデータのキャッシュのみを担当します。データは、Amazon S3、Google Cloud Storage、Azure Blob Storage、MinIO などの低コストで信頼性の高いリモートストレージシステムに保存されます。キャッシュがヒットすると、クエリパフォーマンスは shared nothing アーキテクチャのクエリパフォーマンスと同等になります。必要に応じて、CN ノードを数秒で追加または削除できます。このアーキテクチャは、ストレージコストを削減し、より優れたリソース分離と高い弾力性と拡張性を保証します。

shared-data アーキテクチャは、shared nothing アーキテクチャと同様に、シンプルなアーキテクチャを維持しています。FE と CN の 2 種類のノードのみで構成されています。唯一の違いは、ユーザーがバックエンドオブジェクトストレージを構成する必要があることです。

![shared-data-arch](../_assets/shared-data.png)

#### ノード

shared-data アーキテクチャの FE は、shared nothing アーキテクチャと同じ機能を提供します。

BE は CN (コンピュートノード) に置き換えられ、ストレージ機能はオブジェクトストレージまたは HDFS にオフロードされます。CN は、データストレージを除く、BE のすべての機能を実行するステートレスコンピュートノードです。

#### ストレージ

StarRocks shared-data クラスタは、オブジェクトストレージ (AWS S3、Google GCS、Azure Blob Storage、MinIO など) と HDFS の 2 種類のストレージソリューションをサポートしています。

shared-data クラスタでは、データファイル形式は、shared nothing クラスタ (ストレージとコンピュートが結合されている) のデータファイル形式と一致しています。データはセグメントファイルに編成され、さまざまなインデックス技術がクラウドネイティブテーブルで再利用されます。クラウドネイティブテーブルは、shared-data クラスタでのみ使用されるテーブルです。

#### キャッシュ

StarRocks shared-data クラスタは、データストレージとコンピュートを分離することで、各コンポーネントを個別に拡張できるため、コストが削減され、弾力性が向上します。ただし、このアーキテクチャはクエリパフォーマンスに影響を与える可能性があります。

この影響を軽減するために、StarRocks は、さまざまなビジネスニーズをより適切に満たすために、メモリ、ローカルディスク、およびリモートストレージを含む多層データアクセスシステムを構築しました。

ホットデータに対するクエリはキャッシュを直接スキャンし、次にローカルディスクをスキャンしますが、コールドデータは後続のクエリを高速化するためにオブジェクトストレージからローカルキャッシュにロードする必要があります。ホットデータをコンピュートユニットの近くに配置することで、StarRocks は真に高性能なコンピュートと費用対効果の高いストレージを実現します。さらに、データプリフェッチポリシーによりコールドデータへのアクセスが最適化され、クエリのパフォーマンス制限が効果的に解消されます。

テーブルの作成時にキャッシュを有効にできます。キャッシュが有効になっている場合、データはローカルディスクとバックエンドオブジェクトストレージに書き込まれます。クエリ中に、CN ノードは最初にローカルディスクからデータを読み取ります。データが見つからない場合は、バックエンドオブジェクトストレージからデータが取得され、同時にローカルディスクにキャッシュされます。

<QSOverview />
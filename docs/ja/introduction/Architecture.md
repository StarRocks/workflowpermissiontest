displayed_sidebar: docs
import QSOverview from '../_assets/commonMarkdown/quickstart-overview-tip.mdx'

# アーキテクチャ

OK

StarRocks は優れたアーキテクチャを備えています。システム全体は「フロントエンド」と「バックエンド」の2種類のコンポーネントのみで構成されています。フロントエンドノードは **FE** と呼ばれます。バックエンドノードは **BE** と **CN** (コンピュートノード) の2種類に分けられます。データがローカルストレージを使用する場合、BE がデプロイされます。データがオブジェクトストレージまたは HDFS に保存される場合、CN がデプロイされます。StarRocks は外部コンポーネントに依存しないため、デプロイとメンテナンスが簡素化されます。ノードはダウンタイムなしで水平にスケールできます。さらに、StarRocks はメタデータとサービスデータの レプリカ メカニズムを備えており、データ信頼性を向上させ、単一障害点（SPOF）を効果的に防止します。

StarRocks は MySQL 通信プロトコルと互換性があり、標準 SQL をサポートしています。ユーザーは MySQL クライアント経由で StarRocks に接続し、即座に価値あるインサイトを得ることができます。

## アーキテクチャの選択肢

StarRocks は、共有なしモード （各 BE がローカルストレージ上にデータの一部を所有する）と 共有データモード （すべてのデータが オブジェクトストレージ または HDFS に保存され、各 CN はローカルストレージ上にキャッシュのみを持つ）をサポートしています。必要に応じて、データの保存場所を決定できます。

![アーキテクチャの選択肢](../_assets/architecture_choices.png)

### 共有なしモード
ローカルストレージは、リアルタイムクエリに対してより優れたクエリレイテンシーを提供します。

典型的な大規模並列処理（MPP）データベースとして、StarRocks は 共有なしアーキテクチャ をサポートしています。このアーキテクチャでは、BE はデータストレージとコンピュートを担当します。BE ノード上のローカルデータに直接アクセスすることで、ローカルコンピュートが可能になり、データ転送やデータコピーを回避し、超高速なクエリと データ分析 パフォーマンスを提供します。このアーキテクチャはマルチ レプリカ データストレージをサポートし、クラスターの 高い同時実行性 クエリ処理能力を強化し、データ信頼性を確保します。 クエリパフォーマンス が最適である必要があるシナリオに理想的です。

![ストレージとコンピュート一体型アーキテクチャ](../_assets/shared-nothing.png)

#### ノード

共有なしアーキテクチャ において、StarRocks は FE と BE の2種類のノードで構成されています。

- FE はメタデータ管理と実行計画の構築を担当します。
- BE は クエリプラン を実行し、データを保存します。BE はローカルストレージを活用してクエリを高速化し、マルチ レプリカ メカニズムを使用してデータの 高可用性 を確保します。

##### FE

FE はメタデータ管理、クライアント接続管理、クエリ計画、およびクエリスケジューリングを担当します。各 FE は BDB JE（Berkeley DB Java Edition）を使用して、完全なメタデータの レプリカ をメモリに保存および維持し、すべての FE 間でのサービスの一貫性を保証します。FE は Leader、Follower、Observer として動作できます。Leader ノードがクラッシュした場合、Follower は Raft プロトコルに基づいて Leader を選出します。

| **FE の役割** | **メタデータ管理** | **Leader 選出** |
| ----------- |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| ---------------------------------- |
| Leader      | Leader FE はメタデータを読み書きします。Follower FE と Observer FE はメタデータを読み取ることしかできません。これらはメタデータの書き込み要求を Leader FE にルーティングします。Leader FE はメタデータを更新し、Raft プロトコルを使用してメタデータの変更を Follower FE と Observer FE に同期します。 データ書き込みは、メタデータの変更が半数以上の Follower FE に同期されて初めて成功と見なされます。 | Leader FE は技術的には Follower ノードでもあり、Follower FE によって選出されます。Leader 選出を実行するには、クラスター内の半数以上の Follower FE がアクティブである必要があります。Leader FE が失敗した場合、Follower FE は新しい Leader 選出を開始します。 |
| Follower    | Follower はメタデータを読み取ることしかできません。これらは Leader FE からのログを同期およびリプレイしてメタデータを更新します。 | Follower は Leader 選出に参加し、クラスター内の半数以上の Follower がアクティブである必要があります。 |
| Observer   | Leader FE からのログを同期およびリプレイしてメタデータを更新します。 | Observer は主にクラスターの 高い同時実行性 を向上させるために使用されます。Observer は Leader 選出に参加しないため、クラスターへの Leader 選出の負荷を増加させません。 |

##### BE

BE はデータストレージと SQL 実行を担当します。

- データストレージ：BE は同等のデータストレージ機能を持ちます。FE は定義済みのルールに従ってデータを BE に分散します。BE は データ取り込み されたデータを変換し、必要な形式でデータを書き込み、データにインデックスを生成します。

- SQL 実行：FE は各 SQL クエリをクエリのセマンティクスに基づいて論理実行計画に解析し、その論理計画を BE で実行できる物理実行計画に変換します。ターゲットデータを格納している BE がクエリを実行します。これにより、データ転送やコピーの必要がなくなり、高い クエリパフォーマンス を実現します。

### 共有データモード

オブジェクトストレージ と HDFS は、コスト、信頼性、および 高拡張性 の面で利点を提供します。ストレージの 高拡張性 に加えて、ストレージとコンピュートの分離 により、CN ノードはデータの再バランスなしでオンデマンドで追加および削除できます。

共有データアーキテクチャ では、BE は「 コンピュートノード (CN)」に置き換えられます。これらはデータ コンピュート タスクとホットデータのキャッシュのみを担当します。データは、Amazon S3、Google Cloud Storage、Azure Blob Storage、MinIO など、低コストで信頼性の高い リモートストレージ システムに保存されます。キャッシュヒットが発生した場合、 クエリパフォーマンス は 共有なしアーキテクチャ に匹敵します。CN ノードは数秒でオンデマンドで追加または削除できます。このアーキテクチャはストレージコストを削減し、より良いリソース分離を確保し、高い柔軟性と 高拡張性 を提供します。

共有データアーキテクチャ は、共有なしアーキテクチャ と同様に、シンプルな設計を維持します。FE と CN の2種類のノードのみで構成されています。唯一の違いは、ユーザーがバックエンドの オブジェクトストレージ をプロビジョニングする必要があることです。

![ストレージとコンピュート分離アーキテクチャ](../_assets/shared-data.png)

#### ノード

共有データアーキテクチャ におけるコーディネーターノードは、共有なしアーキテクチャ における FE と同じ機能を提供します。

BE は CN（ コンピュートノード ）に置き換えられ、ストレージ機能は オブジェクトストレージ または HDFS にオフロードされます。CN は、データストレージを除くすべての BE 機能を実行するステートレスな コンピュートノード です。

#### ストレージ

StarRocks 共有データクラスタ は、オブジェクトストレージ （AWS S3、Google GCS、Azure Blob Storage、MinIO など）と HDFS の2つのストレージソリューションをサポートしています。

共有データクラスタ では、データファイル形式は 共有なしクラスタ （ストレージとコンピュートが結合されている）と一貫しています。データは セグメントファイル に整理され、様々なインデックス技術は、共有データクラスタ で特別に使用される クラウドネイティブテーブル で再利用されます。

#### キャッシュ

StarRocks 共有データクラスタ は、データストレージとコンピュートを分離し、独立してスケーリングできるようにすることで、コストを削減し、柔軟性を向上させます。しかし、このアーキテクチャは クエリパフォーマンス に影響を与える可能性があります。

この影響を軽減するために、StarRocks はメモリ、ローカルディスク、および リモートストレージ をカバーする多層データアクセスシステムを確立し、さまざまなビジネスニーズにさらに対応できるようにしました。

ホットデータクエリはキャッシュを直接スキャンし、次に ローカルディスク をスキャンします。一方、コールドデータは オブジェクトストレージ からローカルキャッシュに ロード され、後続のクエリを高速化する必要があります。ホットデータをコンピュートユニットの近くに保持することで、StarRocks は真に高性能なコンピュートと費用対効果の高いストレージを実現します。さらに、コールドデータアクセスはデータプリフェッチ戦略を通じて最適化され、 クエリパフォーマンス の制限を効果的に排除しています。

テーブルを作成する際にキャッシュを有効にできます。キャッシュが有効になっている場合、データは ローカルディスク とバックエンド オブジェクトストレージ の両方に同時に書き込まれます。クエリ中、CN ノードは最初に ローカルディスク からデータを読み取ります。データが見つからない場合、バックエンド オブジェクトストレージ から取得され、同時に ローカルディスク にキャッシュされます。

<QSOverview />

---
displayed_sidebar: docs
---
import QSOverview from '../_assets/commonMarkdown/quickstart-overview-tip.mdx'

# アーキテクチャ

StarRocksは堅牢なアーキテクチャを持っています。システムはフロントエンドとバックエンドの2種類のコンポーネントのみで構成されています。フロントエンドノードは**FE**と呼ばれます。バックエンドノードには**BE**と**CN** (Compute Nodes) の2種類があります。BEはデータのローカルストレージが使用される場合にデプロイされ、CNはデータがオブジェクトストレージまたはHDFSに保存される場合にデプロイされます。StarRocksは外部コンポーネントに依存せず、デプロイとメンテナンスを簡素化します。ノードはサービス停止時間なしで水平にスケールできます。さらに、StarRocksはメタデータとサービスデータにレプリカメカニズムを備えており、これによりデータの信頼性が向上し、単一障害点 (SPOFs) を効率的に防ぎます。

StarRocksはMySQLプロトコルと互換性があり、標準SQLをサポートしています。ユーザーはMySQLクライアントからStarRocksに簡単に接続でき、瞬時に貴重なインサイトを得ることができます。

## アーキテクチャの選択

StarRocksはShared-nothing（各BEがそのローカルストレージにデータの一部を持つ）とShared-data（すべてのデータがオブジェクトストレージまたはHDFSにあり、各CNがローカルストレージにキャッシュのみを持つ）をサポートしています。ニーズに基づいてデータの保存場所を決定できます。

![アーキテクチャの選択](../_assets/architecture_choices.png)

### Shared-nothing

ローカルストレージはリアルタイムクエリのクエリレイテンシを向上させます。

典型的な大規模並列処理 (MPP) データベースとして、StarRocksはShared-nothingアーキテクチャをサポートしています。このアーキテクチャでは、BEはデータストレージと計算の両方を担当します。BEモードのローカルデータへの直接アクセスは、データ転送とデータコピーを回避し、超高速なクエリと分析性能を提供します。このアーキテクチャはマルチレプリカデータストレージをサポートしており、クラスターが高並行クエリを処理する能力を高め、データ信頼性を確保します。最適なクエリパフォーマンスを追求するシナリオに非常に適しています。

![shared-data-arch](../_assets/shared-nothing.png)

#### ノード

Shared-nothingアーキテクチャでは、StarRocksはFEとBEの2種類のノードで構成されます。

- FEはメタデータ管理と実行計画の構築を担当します。
- BEはクエリ計画を実行し、データを保存します。BEはローカルストレージを利用してクエリを高速化し、マルチレプリカメカニズムによって高いデータ可用性を確保します。

##### FE

FEは、メタデータ管理、クライアント接続管理、クエリ計画、およびクエリスケジューリングを担当します。各FEはBDB JE (Berkeley DB Java Edition) を使用して、メタデータの完全なコピーをメモリに保存および維持し、すべてのFE間で一貫したサービスを保証します。FEはリーダー、フォロワー、オブザーバーとして機能できます。リーダーノードがクラッシュした場合、フォロワーはRaftプロトコルに基づいてリーダーを選出します。

| **FEの役割** | **メタデータ管理**                                                                                                                                                                                                                                                                                                                                                                                                          | **リーダー選出**                                     |
| ----------- |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| -------------------------------------------------- |
| リーダー      | リーダーFEはメタデータを読み書きします。フォロワーFEとオブザーバーFEはメタデータを読み込むことのみ可能です。彼らはメタデータ書き込みリクエストをリーダーFEにルーティングします。リーダーFEはメタデータを更新し、Raftプロトコルを使用してメタデータ変更をフォロワーFEとオブザーバーFEに同期します。データ書き込みは、メタデータ変更がフォロワーFEの過半数に同期された後にのみ成功と見なされます。 | リーダーFEは、技術的にはフォロワーノードでもあり、フォロワーFEの中から選出されます。リーダー選出を行うには、クラスター内のフォロワーFEの過半数がアクティブである必要があります。リーダーFEが障害を起こした場合、フォロワーFEは次のリーダー選出ラウンドを開始します。 |
| フォロワー    | フォロワーはメタデータを読み込むことのみ可能です。リーダーFEからのログを同期してリプレイし、メタデータを更新します。                                                                                                                                                                                                                                                                                                          | フォロワーはリーダー選出に参加します。これには、クラスター内のフォロワーの過半数がアクティブである必要があります。             |
| オブザーバー   | オブザーバーはリーダーFEからのログを同期してリプレイし、メタデータを更新します。                                                                                                                                                                                                                                                                                                                                           | オブザーバーは主にクラスターのクエリ並行性を高めるために使用されます。オブザーバーはリーダー選出に参加しないため、クラスターにリーダー選出のプレッシャーを加えません。 |

##### BE

BEはデータストレージとSQL実行を担当します。

- データストレージ: BEは同等のデータストレージ機能を持ちます。FEは事前定義されたルールに基づいてデータをBEに分散します。BEはインジェストされたデータを変換し、必要なフォーマットでデータを書き込み、データのインデックスを生成します。

- SQL実行: FEは各SQLクエリをクエリのセマンティクスに従って論理実行計画にパースし、その後、論理計画をBE上で実行できる物理実行計画に変換します。目的のデータを保存するBEがクエリを実行します。これにより、データ転送とコピーの必要がなくなり、高いクエリパフォーマンスを実現します。

### Shared-data

オブジェクトストレージとHDFSは、コスト、信頼性、スケーラビリティの利点を提供します。ストレージのスケーラビリティに加えて、ストレージと計算が分離されているため、データの再バランスを行うことなくCNノードを追加および削除できます。

Shared-dataアーキテクチャでは、BEは「Compute Nodes (CNs)」に置き換えられ、データ計算タスクとホットデータのキャッシュのみを担当します。データはAmazon S3、Google Cloud Storage、Azure Blob Storage、MinIOなどの低コストで信頼性の高いリモートストレージシステムに保存されます。キャッシュがヒットした場合、クエリパフォーマンスはShared-nothingアーキテクチャに匹敵します。CNノードは数秒でオンデマンドで追加または削除できます。このアーキテクチャはストレージコストを削減し、より良いリソース分離、高い弾力性、およびスケーラビリティを保証します。

Shared-dataアーキテクチャは、Shared-nothingアーキテクチャと同様にシンプルなアーキテクチャを維持しています。FEとCNの2種類のノードのみで構成されます。唯一の違いは、ユーザーがバックエンドオブジェクトストレージをプロビジョニングする必要があることです。

![shared-data-arch](../_assets/shared-data.png)

#### ノード

Shared-dataアーキテクチャのCoordinator nodesは、Shared-nothingアーキテクチャのFEと同じ機能を提供します。

BEはCN (Compute Nodes) に置き換えられ、ストレージ機能はオブジェクトストレージまたはHDFSにオフロードされます。CNは、データストレージを除くBEのすべての機能を実行するステートレスな計算ノードです。

#### ストレージ

StarRocks Shared-dataクラスターは、2つのストレージソリューションをサポートしています。オブジェクトストレージ（例えば、AWS S3、Google GCS、Azure Blob Storage、またはMinIO）とHDFSです。

Shared-dataクラスターでは、データファイルフォーマットはShared-nothingクラスター（ストレージと計算が結合されたもの）と一貫しています。データはセグメントファイルに整理され、さまざまなインデックス技術がcloud-native tablesで再利用されます。これらはShared-dataクラスターで特別に使用されるテーブルです。

#### キャッシュ

StarRocks Shared-dataクラスターは、データストレージと計算を分離し、それぞれを独立してスケールできるようにすることで、コストを削減し、弾力性を高めます。ただし、このアーキテクチャはクエリパフォーマンスに影響を与える可能性があります。

この影響を軽減するため、StarRocksはメモリ、ローカルディスク、リモートストレージを含む多層データアクセスシステムを確立し、さまざまなビジネスニーズにさらに良く対応します。

ホットデータに対するクエリは、キャッシュを直接スキャンし、次にローカルディスクをスキャンします。一方、コールドデータは、その後のクエリを高速化するために、オブジェクトストレージからローカルキャッシュにロードされる必要があります。ホットデータを計算ユニットに近づけることで、StarRocksは真に高性能な計算と費用対効果の高いストレージを実現します。さらに、コールドデータへのアクセスはデータプリフェッチ戦略によって最適化されており、クエリのパフォーマンス制限を効果的に排除します。

テーブル作成時にキャッシュを有効にすることができます。キャッシュが有効になっている場合、データはローカルディスクとバックエンドオブジェクトストレージの両方に書き込まれます。クエリ中、CNノードはまずローカルディスクからデータを読み取ります。データが見つからない場合、バックエンドオブジェクトストレージから取得され、同時にローカルディスクにキャッシュされます。

<QSOverview />

---
displayed_sidebar: docs
---
import QSOverview from '../_assets/commonMarkdown/quickstart-overview-tip.mdx'

# アーキテクチャ

StarRocksは堅牢なアーキテクチャを備えています。システムは、フロントエンドとバックエンドの2種類のコンポーネントのみで構成されています。フロントエンドノードは**FE**と呼ばれます。バックエンドノードには、**BE**と**CN** (Compute Nodes) の2種類があります。BEはデータのローカルストレージが使用される場合にデプロイされ、CNはデータがオブジェクトストレージまたはHDFSに保存される場合にデプロイされます。StarRocksは外部コンポーネントに依存しないため、デプロイとメンテナンスが簡素化されます。ノードはサービスを停止することなく水平にスケーリングできます。さらに、StarRocksはメタデータとサービスデータのレプリカメカニズムを備えており、データ信頼性を高め、単一障害点（SPOFs）を効果的に防止します。

StarRocksはMySQLプロトコルと互換性があり、標準SQLをサポートしています。ユーザーはMySQLクライアントからStarRocksに簡単に接続でき、即座に貴重なインサイトを得ることができます。

## アーキテクチャの選択肢

StarRocksは、Shared-nothing（各BEがローカルストレージにデータの一部を保持する）とShared-data（すべてのデータがオブジェクトストレージまたはHDFSに保存され、各CNはローカルストレージにキャッシュのみを保持する）をサポートします。必要に応じてデータの保存場所を決定できます。

![Architecture choices](../_assets/architecture_choices.png)

### Shared-nothing

ローカルストレージは、リアルタイムクエリのクエリレイテンシを向上させます。

典型的な大規模並列処理（MPP）データベースとして、StarRocksはShared-nothingアーキテクチャをサポートしています。このアーキテクチャでは、BEはデータストレージと計算の両方を担当します。BEモードでのローカルデータへの直接アクセスにより、ローカル計算が可能になり、データ転送とデータコピーが回避され、超高速のクエリおよび分析パフォーマンスが提供されます。このアーキテクチャはマルチレプリカデータストレージをサポートしており、高並行性クエリを処理するクラスターの能力を高め、データ信頼性を確保します。最適なクエリパフォーマンスを追求するシナリオに適しています。

![shared-data-arch](../_assets/shared-nothing.png)

#### ノード

Shared-nothingアーキテクチャでは、StarRocksはFEとBEの2種類のノードで構成されます。

- FEはメタデータ管理と実行計画の構築を担当します。
- BEはクエリ計画を実行し、データを保存します。BEはローカルストレージを利用してクエリを高速化し、マルチレプリカメカニズムにより高いデータ可用性を確保します。

##### FE

FEはメタデータ管理、クライアント接続管理、クエリ計画、およびクエリスケジューリングを担当します。各FEはBDB JE（Berkeley DB Java Edition）を使用して、メタデータの完全なコピーをメモリに保存および維持し、すべてのFE間で一貫したサービスを保証します。FEはリーダー、フォロワー、オブザーバーとして機能できます。リーダーノードがクラッシュした場合、フォロワーがRaftプロトコルに基づいてリーダーを選出します。

| **FEロール** | **メタデータ管理**                                                                                                                                                                                                                                                                                                                                                                                                | **リーダー選出**                |
| ----------- |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| ---------------------------------- |
| Leader      | リーダーFEはメタデータを読み書きします。フォロワーおよびオブザーバーFEはメタデータのみを読み取ることができます。これらはメタデータ書き込みリクエストをリーダーFEにルーティングします。リーダーFEはメタデータを更新し、Raftプロトコルを使用してメタデータの変更をフォロワーおよびオブザーバーFEに同期します。データ書き込みは、メタデータの変更がフォロワーFEの半分以上に同期された後にのみ成功とみなされます。 | リーダーFEは、技術的にはフォロワーノードでもあり、フォロワーFEから選出されます。リーダー選出を行うには、クラスター内のフォロワーFEの半分以上がアクティブである必要があります。リーダーFEが故障すると、フォロワーFEは別のラウンドのリーダー選出を開始します。 |
| Follower    | フォロワーはメタデータのみを読み取ることができます。彼らはリーダーFEからのログを同期および再生してメタデータを更新します。                                                                                                                                                                                                                                                                               | フォロワーはリーダー選出に参加し、クラスター内のフォロワーの半分以上がアクティブである必要があります。 |
| Observer   | オブザーバーはリーダーFEからのログを同期および再生してメタデータを更新します。                                                                                                                                                                                                                                                                                                                                           | オブザーバーは主にクラスターのクエリ並行性を高めるために使用されます。オブザーバーはリーダー選出に参加しないため、クラスターにリーダー選出のプレッシャーを追加することはありません。|

##### BE

BEはデータストレージとSQL実行を担当します。

- データストレージ：BEは同等のデータストレージ機能を持ちます。FEは定義済みのルールに基づいてデータをBEに分散します。BEは取り込まれたデータを変換し、必要な形式でデータを書き込み、そのデータに対してインデックスを生成します。

- SQL実行：FEは各SQLクエリをクエリのセマンティクスに従って論理実行計画に解析し、その論理計画をBE上で実行できる物理実行計画に変換します。宛先データを保存するBEがクエリを実行します。これにより、データ転送やコピーの必要がなくなり、高いクエリパフォーマンスを実現します。

### Shared-data

オブジェクトストレージとHDFSは、コスト、信頼性、およびスケーラビリティの利点を提供します。ストレージのスケーラビリティに加えて、ストレージと計算が分離されているため、CNノードはデータをリバランスすることなく追加および削除できます。

Shared-dataアーキテクチャでは、BEは「コンピュートノード（CN）」に置き換えられ、これらはデータ計算タスクとホットデータのキャッシュのみを担当します。データは、Amazon S3、Google Cloud Storage、Azure Blob Storage、MinIOなどの低コストで信頼性の高いリモートストレージシステムに保存されます。キャッシュがヒットした場合、クエリパフォーマンスはShared-nothingアーキテクチャに匹敵します。CNノードは数秒でオンデマンドで追加または削除できます。このアーキテクチャは、ストレージコストを削減し、より良いリソース分離と高い弾力性およびスケーラビリティを保証します。

Shared-dataアーキテクチャは、Shared-nothingアーキテクチャと同様にシンプルなアーキテクチャを維持しています。FEとCNの2種類のノードのみで構成されています。唯一の違いは、ユーザーがバックエンドのオブジェクトストレージをプロビジョニングする必要があることです。

![shared-data-arch](../_assets/shared-data.png)

#### ノード

Shared-dataアーキテクチャのコーディネーターノードは、Shared-nothingアーキテクチャのFEと同じ機能を提供します。

BEはCN（Compute Nodes）に置き換えられ、ストレージ機能はオブジェクトストレージまたはHDFSにオフロードされます。CNは、データの保存以外のBEのすべての機能を実行するステートレスなコンピュートノードです。

#### ストレージ

StarRocksのShared-dataクラスターは、オブジェクトストレージ（例：AWS S3、Google GCS、Azure Blob Storage、MinIO）とHDFSの2つのストレージソリューションをサポートしています。

Shared-dataクラスターでは、データファイル形式はShared-nothingクラスター（ストレージと計算が結合されている）と一貫しています。データはセグメントファイルに整理され、Shared-dataクラスターで特別に使用されるテーブルであるcloud-native tablesでは、さまざまなインデックス技術が再利用されます。

#### キャッシュ

StarRocksのShared-dataクラスターは、データストレージと計算を分離し、それぞれを独立してスケーリングできるようにすることで、コストを削減し、弾力性を高めます。ただし、このアーキテクチャはクエリパフォーマンスに影響を与える可能性があります。

この影響を軽減するために、StarRocksはメモリ、ローカルディスク、およびリモートストレージを含む多層データアクセスシステムを確立し、さまざまなビジネスニーズにより良く対応します。

ホットデータに対するクエリは、キャッシュとローカルディスクを直接スキャンしますが、コールドデータはオブジェクトストレージからローカルキャッシュにロードして、その後のクエリを高速化する必要があります。ホットデータを計算ユニットの近くに保つことで、StarRocksは真に高性能な計算とコスト効率の高いストレージを実現します。さらに、コールドデータへのアクセスはデータプリフェッチ戦略で最適化されており、クエリのパフォーマンス制限を効果的に排除します。

キャッシュはテーブル作成時に有効にできます。キャッシュが有効になっている場合、データはローカルディスクとバックエンドオブジェクトストレージの両方に書き込まれます。クエリ中に、CNノードは最初にローカルディスクからデータを読み取ります。データが見つからない場合、バックエンドオブジェクトストレージから取得され、同時にローカルディスクにキャッシュされます。

<QSOverview />

```md
displayed_sidebar: docs
import QSOverview from '../_assets/commonMarkdown/quickstart-overview-tip.mdx'

# アーキテクチャ

StarRocks は強力なアーキテクチャを備えています。システム全体は「フロントエンド」と「バックエンド」の2種類のコンポーネントのみで構成されています。フロントエンドノードは **FE** と呼ばれます。バックエンドノードは **BE** と **CN** (コンピュートノード) の2種類に分けられます。データがローカルストレージを使用する場合はBEがデプロイされ、データがオブジェクトストレージまたはHDFSに保存される場合はCNがデプロイされます。StarRocks は外部コンポーネントに依存しないため、デプロイとメンテナンスが簡素化されます。ノードはダウンタイムなしで水平にスケールできます。さらに、StarRocks はメタデータとサービスデータにレプリカメカニズムを備えており、データ信頼性を向上させ、単一障害点 (SPOF) を効果的に防ぎます。

StarRocks は MySQL 通信プロトコルと互換性があり、標準 SQL をサポートしています。ユーザーは MySQL クライアントを介して StarRocks に接続し、迅速かつ価値のある洞察を得ることができます。

## アーキテクチャの選択肢

StarRocks は、共有なしモード (各BEがローカルストレージにデータの一部を所有する) と共有データモード (すべてのデータがオブジェクトストレージまたはHDFSに保存され、各CNはローカルストレージにキャッシュのみを持つ) をサポートしています。必要に応じてデータをどこに保存するかを決定できます。

![Architecture Choices](../_assets/architecture_choices.png)

### 共有なしモード
ローカルストレージは、リアルタイムクエリに対してより良いクエリレイテンシを提供します。

典型的な大規模並列処理 (MPP) データベースとして、StarRocks は共有なしアーキテクチャをサポートしています。このアーキテクチャでは、BE はデータの保存とコンピューティングを担当します。BE 上のローカルデータに直接アクセスすることで、ローカルコンピューテーションが可能になり、データ転送やデータコピーを回避し、超高速のクエリパフォーマンスとデータ分析パフォーマンスを実現します。このアーキテクチャはマルチレプリカデータストレージをサポートしており、クラスタの高い同時実行性のクエリ処理能力を向上させ、データ信頼性を確保します。最適なクエリパフォーマンスを必要とするシナリオに最適です。

![Shared-nothing Architecture](../_assets/shared-nothing.png)

#### ノード

共有なしアーキテクチャでは、StarRocks は FE と BE の2種類のノードで構成されています。

- FE はメタデータ管理と実行計画の構築を担当します。
- BE はクエリ計画を実行し、データを保存します。BE はローカルストレージを活用してクエリを高速化し、マルチレプリカメカニズムを使用してデータの高可用性を確保します。

##### FE

FE はメタデータ管理、クライアント接続管理、クエリ計画、およびクエリスケジューリングを担当します。各 FE は BDB JE (Berkeley DB Java Edition) を使用して、メタデータの完全なレプリカをメモリに保存および維持し、すべての FE 間でのサービス一貫性を確保します。FE は Leader、Follower、Observer として機能できます。Leader ノードがクラッシュした場合、Follower は Raft プロトコルに従って Leader を選出します。

| **FE の役割** | **メタデータ管理** | **Leader 選出** |
| ----------- |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| ---------------------------------- |
| Leader      | Leader FE はメタデータを読み書きします。Follower FE と Observer FE はメタデータを読み取ることのみ可能です。これらはメタデータ書き込みリクエストを Leader FE にルーティングします。Leader FE はメタデータを更新し、Raft プロトコルを使用してメタデータの変更を Follower FE および Observer FE に同期します。データの書き込みは、メタデータの変更が Follower FE の半数以上に同期されて初めて成功と見なされます。 | Leader FE も技術的には Follower ノードであり、Follower FE によって選出されます。Leader 選出を実行するには、クラスタ内の Follower FE の半数以上がアクティブである必要があります。Leader FE が失敗した場合、Follower FE は新しいラウンドの Leader 選出を開始します。 |
| Follower    | Follower はメタデータを読み取ることのみ可能です。Leader FE からログを同期してリプレイし、メタデータを更新します。 | Follower は Leader 選出に参加し、クラスタ内の Follower の半数以上がアクティブである必要があります。 |
| Observer   | Leader FE からログを同期してリプレイし、メタデータを更新します。 | Observer は主にクラスタのクエリ同時実行性を向上させるために使用されます。Observer は Leader 選出には参加しないため、クラスタの Leader 選出の負荷を増加させません。 |

##### BE

BE はデータストレージと SQL 実行を担当します。

- データストレージ: BE は同等のデータストレージ能力を備えています。FE は事前定義されたルールに従ってデータを BE に分散します。BE は取り込まれたデータを変換し、必要な形式でデータを書き込み、データにインデックスを生成します。

- SQL 実行: FE は各 SQL クエリをクエリのセマンティクスに基づいて論理実行計画に解析し、その論理計画を BE で実行可能な物理実行計画に変換します。対象データを保存する BE がクエリを実行します。これにより、データ転送とコピーの必要性が排除され、高いクエリパフォーマンスが実現します。

### 共有データモード

オブジェクトストレージとHDFSは、コスト、信頼性、および高拡張性の点で利点を提供します。ストレージの高拡張性に加えて、ストレージとコンピュートの分離により、データのリバランスなしでCNノードをオンデマンドで追加および削除できます。

共有データアーキテクチャでは、BEは「コンピュートノード (CN)」に置き換えられ、CNはデータコンピューティングタスクとホットデータのキャッシュのみを担当します。データはAmazon S3、Google Cloud Storage、Azure Blob Storage、MinIO などの低コストで信頼性の高いリモートストレージシステムに保存されます。キャッシュヒット時には、クエリパフォーマンスは共有なしアーキテクチャのそれに匹敵します。CNノードは数秒以内にオンデマンドで追加または削除できます。このアーキテクチャはストレージコストを削減し、より良いリソース分離を保証し、高い弾力性と高拡張性を提供します。

共有データアーキテクチャは、共有なしアーキテクチャと同様に、シンプルなアーキテクチャを維持しています。FEとCNの2種類のノードのみで構成されています。唯一の違いは、ユーザーがバックエンドのオブジェクトストレージをプロビジョニングする必要があることです。

![Shared-data Architecture](../_assets/shared-data.png)

#### ノード

共有データアーキテクチャのコーディネーターノードは、共有なしアーキテクチャのFEと同じ機能を提供します。

BEはCN (コンピュートノード) に置き換えられ、ストレージ機能はオブジェクトストレージまたはHDFSにオフロードされます。CNはステートレスなコンピュートノードであり、データストレージを除くBEのすべての機能を実行します。

#### ストレージ

StarRocks 共有データクラスタは、オブジェクトストレージ (AWS S3、Google GCS、Azure Blob Storage、または MinIO など) と HDFS の2つのストレージソリューションをサポートしています。

共有データクラスタでは、データファイル形式は共有なしクラスタ (ストレージとコンピュートが結合されたもの) と一貫しています。データはSegmentファイルに整理され、さまざまなインデックス作成技術は共有データテーブル、つまり共有データクラスタで特別に使用されるテーブルで再利用されます。

#### キャッシュ

StarRocks 共有データクラスタは、データストレージとコンピュートを分離し、両方を独立してスケールできるようにすることで、コストを削減し、弾力性を向上させます。ただし、このアーキテクチャはクエリパフォーマンスに影響を与える可能性があります。

この影響を軽減するため、StarRocks はメモリ、ローカルディスク、およびリモートストレージをカバーする多層データアクセスシステムを確立し、多様なビジネス要件をより適切に満たします。

ホットデータのクエリはキャッシュを直接スキャンし、次にローカルディスクをスキャンします。一方、コールドデータはオブジェクトストレージからローカルキャッシュにロードされて、その後のクエリが高速化される必要があります。ホットデータをコンピュートユニットの近くに保つことで、StarRocks は真に高性能なコンピュートと費用対効果の高いストレージを実現します。さらに、コールドデータアクセスはデータプリフェッチ戦略によって最適化され、クエリパフォーマンスの制限を効果的に排除します。

テーブル作成時にキャッシュを有効にできます。キャッシュが有効になっている場合、データはローカルディスクとバックエンドのオブジェクトストレージの両方に同時に書き込まれます。クエリ中、CNノードは最初にローカルディスクからデータを読み取ります。データが見つからない場合、バックエンドのオブジェクトストレージから取得され、同時にローカルディスクにキャッシュされます。

<QSOverview />
```

---
displayed_sidebar: docs
---
import QSOverview from '../_assets/commonMarkdown/quickstart-overview-tip.mdx'

# アーキテクチャ

StarRocks は、シンプルなアーキテクチャを採用しています。システム全体は、フロントエンドとバックエンドの 2 種類のコンポーネントのみで構成されています。フロントエンドノードは **FE** と呼ばれます。バックエンドノードには、**BE** と **CN** (Compute Nodes) の 2 種類があります。BE はデータのローカルストレージを使用する場合にデプロイされ、CN はデータがオブジェクトストレージまたは HDFS に保存される場合にデプロイされます。StarRocks は外部コンポーネントに依存しないため、デプロイとメンテナンスが容易です。ノードは、サービスを停止することなく水平方向にスケールできます。また、StarRocks にはメタデータとサービスデータの レプリカ メカニズムがあり、データの信頼性を高め、単一障害点 (SPOF) を効率的に防止します。

StarRocks は MySQL プロトコルと互換性があり、標準 SQL をサポートしています。ユーザーは MySQL クライアントから StarRocks に簡単に接続して、即座に価値のあるインサイトを得ることができます。

## アーキテクチャの選択

StarRocks は、 共有なし (各 BE はローカルストレージにデータの一部を保持します) と 共有データ (オブジェクトストレージまたは HDFS 上のすべてのデータ、および各 CN はローカルストレージにキャッシュのみを保持します) をサポートします。ニーズに応じて、データの保存場所を決定できます。

![Architecture choices](../_assets/architecture_choices.png)

### 共有なし

ローカルストレージは、リアルタイムクエリの クエリパフォーマンス を向上させます。

一般的な超並列処理 (MPP) データベースとして、StarRocks は 共有なし アーキテクチャをサポートしています。このアーキテクチャでは、BE はデータストレージと計算の両方を担当します。BE モードでローカルデータに直接アクセスすることで、ローカルでの計算が可能になり、データ転送とデータコピーを回避し、超高速なクエリと分析のパフォーマンスを実現します。このアーキテクチャは、マルチ レプリカ データストレージをサポートし、クラスタの高い同時実行性クエリを処理する能力を高め、データの信頼性を確保します。最適な クエリパフォーマンス を追求するシナリオに適しています。

![shared-data-arch](../_assets/shared nothing.png)

#### ノード

共有なし アーキテクチャでは、StarRocks は FE と BE の 2 種類のノードで構成されています。

- FE は、メタデータ管理と実行プランの構築を担当します。
- BE は、クエリプラン を実行し、データを保存します。BE はローカルストレージを利用してクエリを高速化し、マルチ レプリカ メカニズムを使用して高いデータ可用性を確保します。

##### FE

FE は、メタデータ管理、クライアント接続管理、クエリプラン 、およびクエリスケジューリングを担当します。各 FE は BDB JE (Berkeley DB Java Edition) を使用して、メモリ内のメタデータの完全なコピーを保存および維持し、すべての FE で一貫したサービスを保証します。FE は、リーダー、フォロワー、およびオブザーバーとして機能できます。リーダーノードがクラッシュした場合、フォロワーは Raft プロトコルに基づいてリーダーを選出します。

| **FE Role** | **Metadata management**                                                                                                                                                                                                                                                                                                                                                                                                | **Leader election**                |
| ----------- |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| ---------------------------------- |
| Leader      | リーダー FE はメタデータを読み書きします。フォロワーおよびオブザーバー FE は、メタデータの読み取りのみ可能です。メタデータの書き込みリクエストをリーダー FE にルーティングします。リーダー FE はメタデータを更新し、Raft プロトコルを使用して、メタデータの変更をフォロワーおよびオブザーバー FE に同期します。データの書き込みは、メタデータの変更がフォロワー FE の半数以上に同期された後にのみ成功したと見なされます。 | 正確に言うと、リーダー FE はフォロワーノードでもあり、フォロワー FE から選出されます。リーダー選出を実行するには、クラスタ内のフォロワー FE の半数以上がアクティブである必要があります。リーダー FE に障害が発生すると、フォロワー FE は別のリーダー選出ラウンドを開始します。 |
| Follower    | フォロワーはメタデータの読み取りのみ可能です。リーダー FE からログを同期および再生して、メタデータを更新します。                                                                                                                                                                                                                                                                                                              | フォロワーはリーダー選出に参加します。これには、クラスタ内のフォロワーの半数以上がアクティブである必要があります。 |
| Observer   | オブザーバーはリーダー FE からログを同期および再生して、メタデータを更新します。                                                                                                                                                                                                                                                                                                                                           | オブザーバーは主に、クラスタのクエリの同時実行性を高めるために使用されます。オブザーバーはリーダー選出に参加しないため、クラスタにリーダー選択のプレッシャーを加えることはありません。|

##### BE

BE は、データストレージと SQL 実行を担当します。

- データストレージ: BE は同等のデータストレージ機能を備えています。FE は、事前定義されたルールに基づいてデータを BE に分散します。BE は取り込まれたデータを変換し、必要な形式でデータを書き込み、データのインデックスを生成します。

- SQL 実行: FE は、クエリのセマンティクスに従って各 SQL クエリを論理実行プランに解析し、次にその論理プランを BE で実行できる物理実行プランに変換します。宛先データを保存する BE がクエリを実行します。これにより、データ伝送とコピーの必要がなくなり、高い クエリパフォーマンス が実現します。

### 共有データ

オブジェクトストレージと HDFS は、コスト、信頼性、および拡張性の利点を提供します。ストレージの拡張性に加えて、ストレージとコンピュートが分離されているため、データをリバランスする必要なく CN ノードを追加および削除できます。

共有データ アーキテクチャでは、BE は「コンピュートノード (CN)」に置き換えられます。これは、データコンピュートタスクとホットデータのキャッシュのみを担当します。データは、Amazon S3、Google Cloud Storage、Azure Blob Storage、MinIO などの低コストで信頼性の高いリモートストレージシステムに保存されます。キャッシュがヒットすると、クエリパフォーマンス は 共有なし アーキテクチャの クエリパフォーマンス に匹敵します。CN ノードは、必要に応じて数秒以内に追加または削除できます。このアーキテクチャにより、ストレージコストが削減され、より優れたリソース分離、高い弾力性と拡張性が確保されます。

共有データ アーキテクチャは、 共有なし のアーキテクチャと同様にシンプルなアーキテクチャを維持します。FE と CN の 2 種類のノードのみで構成されています。唯一の違いは、ユーザーがバックエンドオブジェクトストレージをプロビジョニングする必要があることです。

![shared-data-arch](../_assets/shared-data.png)

#### ノード

共有データ アーキテクチャの FE は、 共有なし アーキテクチャと同じ機能を提供します。

BE は CN (Compute Nodes) に置き換えられ、ストレージ機能はオブジェクトストレージまたは HDFS にオフロードされます。CN は、データのストレージを除く、BE のすべての機能を実行するステートレスコンピュートノードです。

#### ストレージ

StarRocks 共有データ クラスタは、オブジェクトストレージ (たとえば、AWS S3、Google GCS、Azure Blob Storage、または MinIO) と HDFS の 2 つのストレージソリューションをサポートしています。

共有データ クラスタでは、データファイル形式は 共有なし クラスタ (ストレージとコンピュートが結合されている) と一貫しています。データは セグメントファイル に編成され、さまざまなインデックス作成テクノロジーが クラウドネイティブテーブル で再利用されます。これらは、共有データ クラスタで特に使用されるテーブルです。

#### キャッシュ

StarRocks 共有データ クラスタは、データストレージと計算を分離し、それぞれが独立してスケールできるようにすることで、コストを削減し、弾力性を高めます。ただし、このアーキテクチャは クエリパフォーマンス に影響を与える可能性があります。

影響を軽減するために、StarRocks は、さまざまなビジネスニーズをより適切に満たすために、メモリ、ローカルディスク、およびリモートストレージを含む多層データアクセスシステムを確立します。

ホットデータに対するクエリは、キャッシュを直接スキャンしてからローカルディスクをスキャンしますが、コールドデータは、後続のクエリを高速化するために、オブジェクトストレージからローカルキャッシュにロードする必要があります。ホットデータをコンピュートユニットの近くに保持することで、StarRocks は真に高性能な計算と費用対効果の高いストレージを実現します。さらに、コールドデータへのアクセスは、データプリフェッチ戦略で最適化されており、クエリのパフォーマンス制限を効果的に排除します。

キャッシュは、テーブルの作成時に有効にできます。キャッシュを有効にすると、データはローカルディスクとバックエンドオブジェクトストレージの両方に書き込まれます。クエリ中、CN ノードは最初にローカルディスクからデータを読み取ります。データが見つからない場合は、バックエンドオブジェクトストレージから取得され、同時にローカルディスクにキャッシュされます。

<QSOverview />
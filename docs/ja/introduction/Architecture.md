displayed_sidebar: docs
import QSOverview from '../_assets/commonMarkdown/quickstart-overview-tip.mdx'

# アーキテクチャ

StarRocksは素晴らしいアーキテクチャを持っています。システム全体は「フロントエンド」と「バックエンド」の2種類のコンポーネントのみで構成されています。フロントエンドノードは**FE**と呼ばれます。バックエンドノードは**BE**と**CN**（コンピュートノード）の2種類に分かれます。データがローカルストレージを使用する場合、BEがデプロイされ、データがオブジェクトストレージまたはHDFSに保存される場合、CNがデプロイされます。StarRocksはいかなる外部コンポーネントにも依存せず、デプロイとメンテナンスを簡素化します。ノードはダウンタイムなしで水平にスケールアウトできます。さらに、StarRocksはメタデータとサービスデータのレプリカメカニズムを備えており、データ信頼性を向上させ、単一障害点（SPOFs）を効果的に防止します。

StarRocksはMySQL通信プロトコルと互換性があり、標準SQLをサポートしています。ユーザーはMySQLクライアントを介してStarRocksに接続し、即座に価値あるインサイトを得ることができます。

## アーキテクチャの選択

StarRocksは、Shared-nothingモード（各BEがそのローカルストレージ上にデータの一部を所有する）とShared-dataモード（すべてのデータがオブジェクトストレージまたはHDFSに保存され、各CNはそのローカルストレージ上にキャッシュのみを持つ）をサポートしています。要件に基づいてデータの保存場所を決定できます。

![アーキテクチャの選択](../_assets/architecture_choices.png)

### Shared-nothingモード
ローカルストレージは、リアルタイムクエリに対してより良いクエリレイテンシを提供します。

典型的なMassively Parallel Processing (MPP) データベースとして、StarRocksはShared-nothingアーキテクチャをサポートしています。このアーキテクチャでは、BEはデータストレージと計算を担当します。BEノード上のローカルデータに直接アクセスすることで、ローカル計算が可能になり、データ転送やデータコピーを回避し、超高速なクエリとデータ分析パフォーマンスを提供します。このアーキテクチャは、マルチレプリカデータストレージをサポートし、クラスターの同時実行性の高いクエリ処理能力を高め、データ信頼性を確保します。最適なクエリパフォーマンスを必要とするシナリオに理想的です。

![ストレージと計算が一体となったアーキテクチャ](../_assets/shared-nothing.png)

#### ノード

Shared-nothingアーキテクチャにおいて、StarRocksはFEとBEの2種類のノードで構成されています。

- FEはメタデータ管理と実行計画の構築を担当します。
- BEはクエリ計画を実行し、データを保存します。BEはローカルストレージを活用してクエリを高速化し、マルチレプリカメカニズムを使用してデータの高可用性を確保します。

##### FE

FEは、メタデータ管理、クライアント接続管理、クエリ計画、クエリスケジューリングを担当します。各FEはBDB JE (Berkeley DB Java Edition) を使用して、メタデータの完全なレプリカをメモリに保存・維持し、すべてのFE間でサービスの一貫性を確保します。FEはLeader、Follower、Observerとして動作できます。Leaderノードがクラッシュした場合、FollowerはRaftプロトコルに基づいてLeaderを選出します。

| **FEの役割** | **メタデータ管理** | **リーダー選出** |
| ----------- |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| ---------------------------------- |
| Leader      | Leader FEはメタデータを読み書きします。FollowerおよびObserver FEはメタデータのみを読み取ることができます。これらのFEはメタデータ書き込み要求をLeader FEにルーティングします。Leader FEはメタデータを更新した後、Raftプロトコルを使用してメタデータ変更をFollowerおよびObserver FEに同期します。データ書き込みは、メタデータ変更がFollower FEの半数以上に同期されて初めて成功とみなされます。 | Leader FEは、技術的にはFollower FEによって選出されたFollowerノードでもあります。リーダー選出を行うには、クラスター内のFollower FEの半数以上がアクティブである必要があります。Leader FEが失敗した場合、Follower FEは新しいラウンドのリーダー選出を開始します。 |
| Follower    | Followerはメタデータのみを読み取ることができます。Leader FEからのログを同期およびリプレイしてメタデータを更新します。                                                                                                                                                                                                                                                                                                              | Followerはリーダー選出に参加します。これには、クラスター内のFollowerの半数以上がアクティブである必要があります。 |
| Observer   | Leader FEからのログを同期およびリプレイしてメタデータを更新します。                                                                                                                                                                                                                                                                                                                                           | Observerは主にクラスターのクエリ同時実行性を向上させるために使用されます。Observerはリーダー選出に参加しないため、クラスターへのリーダー選出のプレッシャーを増加させません。 |

##### BE

BEはデータストレージとSQL実行を担当します。

- データストレージ：BEは同等のデータストレージ能力を持っています。FEは定義済みのルールに従ってBEにデータを分散します。BEは取り込まれたデータを変換し、必要な形式でデータを書き込み、データのインデックスを生成します。

- SQL実行：FEは、クエリのセマンティクスに基づいて各SQLクエリを論理実行計画に解析し、その論理計画をBEで実行できる物理実行計画に変換します。ターゲットデータを保存しているBEがクエリを実行します。これにより、データ転送やコピーの必要がなくなり、高いクエリパフォーマンスを実現します。

### Shared-dataモード

オブジェクトストレージとHDFSは、コスト、信頼性、スケーラビリティの面で利点を提供します。ストレージのスケーラビリティに加えて、ストレージと計算の分離により、データのリバランスなしでCNノードをオンデマンドで追加および削除できます。

Shared-dataアーキテクチャでは、BEは「コンピュートノード (CN)」に置き換えられ、データ計算タスクとホットデータのキャッシングのみを担当します。データは、Amazon S3、Google Cloud Storage、Azure Blob Storage、MinIOなどの低コストで信頼性の高いリモートストレージシステムに保存されます。キャッシュがヒットした場合、クエリパフォーマンスはShared-nothingアーキテクチャに匹敵します。CNノードは数秒でオンデマンドに追加または削除できます。このアーキテクチャはストレージコストを削減し、より良いリソース分離を保証し、高い弾力性とスケーラビリティを提供します。

Shared-dataアーキテクチャは、Shared-nothingアーキテクチャと同様に、シンプルな設計を維持しています。FEとCNの2種類のノードのみで構成されます。唯一の違いは、ユーザーがバックエンドオブジェクトストレージをプロビジョニングする必要があることです。

![ストレージと計算が分離されたアーキテクチャ](../_assets/shared-data.png)

#### ノード

Shared-dataアーキテクチャにおけるコーディネーターノードは、Shared-nothingアーキテクチャにおけるFEと同じ機能を提供します。

BEはCN（コンピュートノード）に置き換えられ、ストレージ機能はオブジェクトストレージまたはHDFSにオフロードされます。CNは、データストレージを除くすべてのBE機能を実行するステートレスなコンピュートノードです。

#### ストレージ

StarRocks Shared-dataクラスターは、オブジェクトストレージ（AWS S3、Google GCS、Azure Blob Storage、MinIOなど）とHDFSの2つのストレージソリューションをサポートしています。

Shared-dataクラスターでは、データファイル形式はShared-nothingクラスター（ストレージと計算が結合されている）と一貫しています。データはセグメントファイルに整理され、Shared-dataクラスターで specifically使用されるテーブルであるCloud-nativeテーブルでは、様々なインデックス技術が再利用されます。

#### キャッシュ

StarRocks Shared-dataクラスターは、データストレージと計算を分離し、独立してスケーリングできるようにすることで、コストを削減し、弾力性を向上させます。しかし、このアーキテクチャはクエリパフォーマンスに影響を与える可能性があります。

この影響を軽減するため、StarRocksはメモリ、ローカルディスク、リモートストレージをカバーする多層データアクセスシステムを確立し、様々なビジネスニーズに柔軟に対応できるようにしています。

ホットデータクエリはキャッシュを直接スキャンし、次にローカルディスクをスキャンします。一方、コールドデータはオブジェクトストレージからローカルキャッシュにロードして、その後のクエリを高速化する必要があります。ホットデータを計算ユニットの近くに保つことで、StarRocksは真に高性能な計算と費用対効果の高いストレージを実現します。さらに、データプリフェッチ戦略を通じてコールドデータアクセスが最適化され、クエリパフォーマンスの制限が効果的に排除されています。

テーブル作成時にキャッシングを有効にできます。キャッシングが有効になっている場合、データはローカルディスクとバックエンドオブジェクトストレージの両方に同時に書き込まれます。クエリ中、CNノードは最初にローカルディスクからデータを読み取ります。データが見つからない場合、バックエンドオブジェクトストレージから取得され、同時にローカルディスクにキャッシュされます。

<QSOverview />

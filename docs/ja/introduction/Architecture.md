displayed_sidebar: docs
import QSOverview from '../_assets/commonMarkdown/quickstart-overview-tip.mdx'

# アーキテクチャ

StarRocksは素晴らしいアーキテクチャを持っています。システム全体は「フロントエンド」と「バックエンド」の2種類のコンポーネントのみで構成されています。フロントエンドノードは**FE**と呼ばれます。バックエンドノードは**BE**と**CN**（コンピュートノード）の2種類に分けられます。データがローカルストレージを使用する場合はBEがデプロイされ、データがオブジェクトストレージまたはHDFSに保存される場合はCNがデプロイされます。StarRocksは外部コンポーネントに依存しないため、デプロイとメンテナンスが簡素化されます。ノードはダウンタイムなしで水平方向にスケールできます。さらに、StarRocksはメタデータとサービスデータにレプリカメカニズムを備えており、データ信頼性を向上させ、単一障害点（SPOF）を効果的に防止します。

StarRocksはMySQL通信プロトコルと互換性があり、標準SQLをサポートしています。ユーザーはMySQLクライアントを介してStarRocksに接続し、即座に貴重な洞察を得ることができます。

## アーキテクチャの選択

StarRocksは、共有 nothing モード（各BEがそのローカルストレージにデータの一部を所有する）と、共有データモード（すべてのデータがオブジェクトストレージまたはHDFSに保存され、各CNはそのローカルストレージにキャッシュのみを持つ）をサポートしています。必要に応じてデータを保存する場所を決定できます。

![アーキテクチャの選択](../_assets/architecture_choices.png)

### 共有 nothing モード
ローカルストレージは、リアルタイムクエリに対してより優れたクエリレイテンシを提供します。

典型的な大規模並列処理（MPP）データベースとして、StarRocksは共有 nothing アーキテクチャをサポートしています。このアーキテクチャでは、BEはデータストレージと計算を担当します。BEノード上のローカルデータに直接アクセスすることで、ローカルでの計算が可能になり、データ転送やデータコピーが回避され、超高速のクエリおよびデータ分析パフォーマンスが提供されます。このアーキテクチャは、マルチレプリカデータストレージをサポートし、高並行クエリを処理するクラスターの能力を向上させ、データ信頼性を確保します。最適なクエリパフォーマンスを必要とするシナリオに理想的です。

![ストレージと計算の統合アーキテクチャ](../_assets/shared-nothing.png)

#### ノード

共有 nothing アーキテクチャでは、StarRocksはFEとBEの2種類のノードで構成されています。

- FEはメタデータ管理と実行計画の構築を担当します。
- BEはクエリ計画を実行し、データを保存します。BEはローカルストレージを活用してクエリを高速化し、マルチレプリカメカニズムを使用してデータの高可用性を確保します。

##### FE

FEは、メタデータ管理、クライアント接続管理、クエリ計画、およびクエリスケジューリングを担当します。各FEはBDB JE（Berkeley DB Java Edition）を使用して、メモリ内にメタデータの完全なレプリカを保存および維持し、すべてのFE間でサービスの一貫性を確保します。FEはLeader、Follower、Observerとして動作できます。Leaderノードがクラッシュした場合、FollowerはRaftプロトコルに基づいてLeaderを選出します。

| **FEの役割** | **メタデータ管理**                                                                                                                                                                                                                                                                                                                                                                                                | **Leader選出**                |
| ----------- |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| ---------------------------------- |
| Leader      | Leader FEはメタデータを読み書きします。FollowerおよびObserver FEはメタデータを読み取るのみです。これらはメタデータ書き込みリクエストをLeader FEにルーティングします。Leader FEはメタデータを更新し、その後Raftプロトコルを使用してメタデータの変更をFollowerおよびObserver FEに同期します。データ書き込みは、メタデータの変更がFollower FEの半数以上に同期された後にのみ成功と見なされます。 | Leader FEは、技術的にはFollower FEによって選出されたFollowerノードでもあります。Leader選出を行うには、クラスター内のFollower FEの半数以上がアクティブである必要があります。Leader FEが失敗すると、Follower FEは新たなLeader選出を開始します。 |
| Follower    | Followerはメタデータを読み取るのみです。これらはLeader FEからのログを同期してリプレイし、メタデータを更新します。                                                                                                                                                                                                                                                                                                              | FollowerはLeader選出に参加し、クラスター内のFollowerの半数以上がアクティブである必要があります。 |
| Observer   | Leader FEからのログを同期してリプレイし、メタデータを更新します。                                                                                                                                                                                                                                                                                                                                           | Observerは主にクラスターのクエリ並行性を向上させるために使用されます。ObserverはLeader選出には参加しないため、クラスターへのLeader選出の負荷を増加させません。 |

##### BE

BEはデータストレージとSQL実行を担当します。

- データストレージ: BEは同等のデータストレージ能力を持っています。FEは事前定義されたルールに従ってデータをBEに配布します。BEは取り込まれたデータを変換し、必要な形式でデータを書き込み、そのデータのインデックスを生成します。

- SQL実行: FEは、各SQLクエリをクエリのセマンティクスに基づいて論理実行計画に解析し、その後論理計画をBEで実行できる物理実行計画に変換します。ターゲットデータを保存するBEがクエリを実行します。これにより、データ転送やコピーの必要がなくなり、高いクエリパフォーマンスが達成されます。

### 共有データモード

オブジェクトストレージとHDFSは、コスト、信頼性、スケーラビリティの面で利点を提供します。ストレージのスケーラビリティに加えて、ストレージと計算の分離により、CNノードはデータの再バランスなしでオンデマンドで追加および削除できます。

共有データアーキテクチャでは、BEは「コンピュートノード（CN）」に置き換えられ、データ計算タスクとホットデータのキャッシュのみを担当します。データは、Amazon S3、Google Cloud Storage、Azure Blob Storage、MinIOなどの低コストで信頼性の高いリモートストレージシステムに保存されます。キャッシュがヒットした場合、クエリパフォーマンスは共有 nothing アーキテクチャに匹敵します。CNノードは数秒でオンデマンドで追加または削除できます。このアーキテクチャはストレージコストを削減し、より良いリソース分離を保証し、高い弾力性とスケーラビリティを提供します。

共有データアーキテクチャは、共有 nothing アーキテクチャと同様に、シンプルな設計を維持します。FEとCNの2種類のノードのみで構成されます。唯一の違いは、ユーザーがバックエンドのオブジェクトストレージをプロビジョニングする必要があることです。

![ストレージと計算の分離アーキテクチャ](../_assets/shared-data.png)

#### ノード

共有データアーキテクチャにおけるコーディネーターノードは、共有 nothing アーキテクチャにおけるFEと同じ機能を提供します。

BEはCN（コンピュートノード）に置き換えられ、ストレージ機能はオブジェクトストレージまたはHDFSにオフロードされます。CNは、データストレージを除くすべてのBE機能を実行するステートレスなコンピュートノードです。

#### ストレージ

StarRocksの共有データクラスターは、2つのストレージソリューション、すなわちオブジェクトストレージ（AWS S3、Google GCS、Azure Blob Storage、MinIOなど）とHDFSをサポートしています。

共有データクラスターでは、データファイル形式は共有 nothing クラスター（ストレージと計算が結合されている）と一貫しています。データはセグメントファイルに整理され、さまざまなインデックス技術が、共有データクラスターで特別に使用されるCloud-nativeテーブルで再利用されます。

#### キャッシュ

StarRocksの共有データクラスターはデータストレージと計算を分離し、独立してスケーリングできるようにすることで、コストを削減し、弾力性を高めます。しかし、このアーキテクチャはクエリパフォーマンスに影響を与える可能性があります。

その影響を軽減するために、StarRocksはメモリ、ローカルディスク、リモートストレージをカバーする多層データアクセスシステムを確立し、さまざまなビジネスニーズにさらに対応します。

ホットデータのクエリは直接キャッシュをスキャンし、次にローカルディスクをスキャンします。一方、コールドデータはオブジェクトストレージからローカルキャッシュにロードされ、その後のクエリを高速化する必要があります。ホットデータを計算ユニットの近くに保つことで、StarRocksは真に高性能な計算とコスト効率の良いストレージを実現します。さらに、コールドデータアクセスはデータプリフェッチ戦略によって最適化され、クエリパフォーマンスの制限を効果的に排除しています。

テーブル作成時にキャッシュを有効にすることができます。キャッシュが有効になっている場合、データはローカルディスクとバックエンドのオブジェクトストレージの両方に同時に書き込まれます。クエリ中、CNノードは最初にローカルディスクからデータを読み取ります。データが見つからない場合、バックエンドのオブジェクトストレージから取得され、同時にローカルディスクにキャッシュされます。

<QSOverview />
